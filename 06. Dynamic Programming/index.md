## [14501 퇴사](https://www.acmicpc.net/problem/14501)<br>

### 접근

백준이가 퇴사일까지 할 수 있는 상담 조합은 둘 중 하나에 속한다.
첫 날에 상담하거나, 상담하지 않는 경우이다.
따라서 백준이가 받을 수 있는 최대 수익은 (1) 첫 째날 일을 하고, 이후에 일을 할 수 있는 날부터 일을 했을 때 얻는 최대 수익 또는 (2) 첫 째날 일을 하지 않고 다음 날부터 일을 할 때 얻는 최대 수익이다
`getMaxPay(n) = Math.max(n + t - 1 < dDay ? p + getMaxPay(n + t) : getMaxPay(n + t), getgetMaxPay(n + 1))`
<br> 최대 수익을 얻기 위해 재귀호출을 하며, 이 때 각 부분 문제들이 동일한 부분 문제에 의존한다. 따라서 동적 계획법을 이용해 구현할 수 있다.

### 알고리즘

dp 배열을 선언하고, 해당 날짜가 dDay 가 넘었다면 0 을 리턴하고,
이미 계산한 적이 있다면 해당 값을 return 한다.
위에서 언급한 수도코드에 기반해 재귀적으로 함수를 호출해 최대값을 계산한다.
해당 함수는 계산된 값을 반환한다.
**시간 복잡도는** 한 번 계산한 값은 다시 계산하지 않고 캐시를 참조하기 때문에 O(n) 이다
`존재하는 부분 문제의 수 x 한 부분 문제를 풀 때 필요한 횟수`

### REFERENCE

[참고 블로그](https://cider.tistory.com/14)
